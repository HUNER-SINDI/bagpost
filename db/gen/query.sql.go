// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addToInStoreBalance = `-- name: AddToInStoreBalance :exec
UPDATE store_balances
SET in_store_balance = in_store_balance + $1,
    updated_at = now()
WHERE store_owner_id = $2
`

type AddToInStoreBalanceParams struct {
	InStoreBalance pgtype.Int4
	StoreOwnerID   pgtype.Int4
}

func (q *Queries) AddToInStoreBalance(ctx context.Context, arg AddToInStoreBalanceParams) error {
	_, err := q.db.Exec(ctx, addToInStoreBalance, arg.InStoreBalance, arg.StoreOwnerID)
	return err
}

const countDeliveriesById = `-- name: CountDeliveriesById :one
SELECT COUNT(*) FROM deliveries WHERE store_owner_id = $1
`

func (q *Queries) CountDeliveriesById(ctx context.Context, storeOwnerID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countDeliveriesById, storeOwnerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDeliveryActionEmployee = `-- name: CreateDeliveryActionEmployee :one
INSERT INTO delivery_actions_employee (
    delivery_id,
    employee_id,
    price
) VALUES (
    $1, $2, $3
)
RETURNING id, delivery_id, employee_id, price, is_done, created_at
`

type CreateDeliveryActionEmployeeParams struct {
	DeliveryID int32
	EmployeeID int32
	Price      int32
}

func (q *Queries) CreateDeliveryActionEmployee(ctx context.Context, arg CreateDeliveryActionEmployeeParams) (DeliveryActionsEmployee, error) {
	row := q.db.QueryRow(ctx, createDeliveryActionEmployee, arg.DeliveryID, arg.EmployeeID, arg.Price)
	var i DeliveryActionsEmployee
	err := row.Scan(
		&i.ID,
		&i.DeliveryID,
		&i.EmployeeID,
		&i.Price,
		&i.IsDone,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateStoreAccountById = `-- name: DeactivateStoreAccountById :exec
UPDATE store_owners
SET is_active = false
WHERE id = $1
`

func (q *Queries) DeactivateStoreAccountById(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deactivateStoreAccountById, id)
	return err
}

const deleteWarehouse = `-- name: DeleteWarehouse :exec
DELETE FROM warehouses
WHERE id = $1
`

func (q *Queries) DeleteWarehouse(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteWarehouse, id)
	return err
}

const getAdminByEmailAndPassword = `-- name: GetAdminByEmailAndPassword :one
SELECT id, email, password, created_at, updated_at FROM admins
WHERE email = $1 AND password = $2
LIMIT 1
`

type GetAdminByEmailAndPasswordParams struct {
	Email    string
	Password string
}

func (q *Queries) GetAdminByEmailAndPassword(ctx context.Context, arg GetAdminByEmailAndPasswordParams) (Admin, error) {
	row := q.db.QueryRow(ctx, getAdminByEmailAndPassword, arg.Email, arg.Password)
	var i Admin
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllAds = `-- name: GetAllAds :many
SELECT id, url FROM ads
`

func (q *Queries) GetAllAds(ctx context.Context) ([]Ad, error) {
	rows, err := q.db.Query(ctx, getAllAds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(&i.ID, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRoutesByWarehouseId = `-- name: GetAllRoutesByWarehouseId :many
SELECT 
  cr.id,
  cr.city_name_en,
  cr.city_name_ar,
  cr.city_name_ku,
  COALESCE(
    (
      SELECT json_agg(
        json_build_object(
          'id', sc.id,
          'subcity_name_en', sc.subcity_name_en,
          'subcity_name_ar', sc.subcity_name_ar,
          'subcity_name_ku', sc.subcity_name_ku,
          'price', sc.price
        )
      )
      FROM subcities sc
      WHERE sc.city_route_id = cr.id
    ), '[]'
  ) AS subcities
FROM city_routes cr WHERE cr.warehouse_id = $1
ORDER BY cr.id
`

type GetAllRoutesByWarehouseIdRow struct {
	ID         int32
	CityNameEn pgtype.Text
	CityNameAr pgtype.Text
	CityNameKu pgtype.Text
	Subcities  interface{}
}

func (q *Queries) GetAllRoutesByWarehouseId(ctx context.Context, warehouseID pgtype.Int4) ([]GetAllRoutesByWarehouseIdRow, error) {
	rows, err := q.db.Query(ctx, getAllRoutesByWarehouseId, warehouseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRoutesByWarehouseIdRow
	for rows.Next() {
		var i GetAllRoutesByWarehouseIdRow
		if err := rows.Scan(
			&i.ID,
			&i.CityNameEn,
			&i.CityNameAr,
			&i.CityNameKu,
			&i.Subcities,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStoreBalanceById = `-- name: GetAllStoreBalanceById :one
SELECT id, store_owner_id, in_store_balance, pending_balance, paid_balance, refused_balance, updated_at FROM store_balances WHERE id = $1
`

func (q *Queries) GetAllStoreBalanceById(ctx context.Context, id int32) (StoreBalance, error) {
	row := q.db.QueryRow(ctx, getAllStoreBalanceById, id)
	var i StoreBalance
	err := row.Scan(
		&i.ID,
		&i.StoreOwnerID,
		&i.InStoreBalance,
		&i.PendingBalance,
		&i.PaidBalance,
		&i.RefusedBalance,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliveryByBarcode = `-- name: GetDeliveryByBarcode :one
SELECT id, barcode, store_owner_id, customer_phone, note, from_city_ku, from_city_en, from_city_ar, to_city_ku, to_city_en, to_city_ar, to_subcity_ku, to_subcity_en, to_subcity_ar, to_specific_location, status, price, fdelivery_fee, total_price, warehouse_id, created_at FROM deliveries WHERE barcode = $1 LIMIT 1
`

func (q *Queries) GetDeliveryByBarcode(ctx context.Context, barcode string) (Delivery, error) {
	row := q.db.QueryRow(ctx, getDeliveryByBarcode, barcode)
	var i Delivery
	err := row.Scan(
		&i.ID,
		&i.Barcode,
		&i.StoreOwnerID,
		&i.CustomerPhone,
		&i.Note,
		&i.FromCityKu,
		&i.FromCityEn,
		&i.FromCityAr,
		&i.ToCityKu,
		&i.ToCityEn,
		&i.ToCityAr,
		&i.ToSubcityKu,
		&i.ToSubcityEn,
		&i.ToSubcityAr,
		&i.ToSpecificLocation,
		&i.Status,
		&i.Price,
		&i.FdeliveryFee,
		&i.TotalPrice,
		&i.WarehouseID,
		&i.CreatedAt,
	)
	return i, err
}

const getDeliveryRoutes = `-- name: GetDeliveryRoutes :many
SELECT id, delivery_id, setter_ku, setter_en, setter_ar, created_at FROM delivery_routing WHERE delivery_id = $1 ORDER BY created_at ASC
`

func (q *Queries) GetDeliveryRoutes(ctx context.Context, deliveryID int32) ([]DeliveryRouting, error) {
	rows, err := q.db.Query(ctx, getDeliveryRoutes, deliveryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryRouting
	for rows.Next() {
		var i DeliveryRouting
		if err := rows.Scan(
			&i.ID,
			&i.DeliveryID,
			&i.SetterKu,
			&i.SetterEn,
			&i.SetterAr,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeliveryStatusByStoreId = `-- name: GetDeliveryStatusByStoreId :many
SELECT status, COUNT(*) as count
FROM deliveries
WHERE store_owner_id = $1
GROUP BY status
`

type GetDeliveryStatusByStoreIdRow struct {
	Status string
	Count  int64
}

func (q *Queries) GetDeliveryStatusByStoreId(ctx context.Context, storeOwnerID int32) ([]GetDeliveryStatusByStoreIdRow, error) {
	rows, err := q.db.Query(ctx, getDeliveryStatusByStoreId, storeOwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeliveryStatusByStoreIdRow
	for rows.Next() {
		var i GetDeliveryStatusByStoreIdRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeliverySummaryByEmployee = `-- name: GetDeliverySummaryByEmployee :one
WITH counts_and_sums AS (
    SELECT 
        COUNT(*) AS count_is_done_false,
        SUM(price) AS sum_price_is_done_false
    FROM 
        delivery_actions_employee 
    WHERE 
        is_done = false
        AND employee_id = $1  -- Parameterized employee_id
),
delivery_sums AS (
    SELECT 
        SUM(d.price) AS total_delivery_price,
        SUM(d.total_price) AS total_price,
        SUM(d.fdelivery_fee) AS total_fee
    FROM 
        delivery_actions_employee dea
    JOIN 
        deliveries d ON dea.delivery_id = d.id
    WHERE 
        dea.is_done = false
        AND dea.employee_id = $1  -- Parameterized employee_id
)
SELECT 
    cas.count_is_done_false,
    cas.sum_price_is_done_false,
    ds.total_delivery_price,
    ds.total_price,
    ds.total_fee,
    e.balance,
    e.setter_ku,
    e.setter_en,
    e.setter_ar
FROM 
    counts_and_sums cas,
    delivery_sums ds
JOIN
    empl e ON e.id = $1
`

type GetDeliverySummaryByEmployeeRow struct {
	CountIsDoneFalse    int64
	SumPriceIsDoneFalse int64
	TotalDeliveryPrice  int64
	TotalPrice          int64
	TotalFee            int64
	Balance             pgtype.Int4
	SetterKu            pgtype.Text
	SetterEn            pgtype.Text
	SetterAr            pgtype.Text
}

func (q *Queries) GetDeliverySummaryByEmployee(ctx context.Context, id int32) (GetDeliverySummaryByEmployeeRow, error) {
	row := q.db.QueryRow(ctx, getDeliverySummaryByEmployee, id)
	var i GetDeliverySummaryByEmployeeRow
	err := row.Scan(
		&i.CountIsDoneFalse,
		&i.SumPriceIsDoneFalse,
		&i.TotalDeliveryPrice,
		&i.TotalPrice,
		&i.TotalFee,
		&i.Balance,
		&i.SetterKu,
		&i.SetterEn,
		&i.SetterAr,
	)
	return i, err
}

const getDeliveryTransferByDeliveryID = `-- name: GetDeliveryTransferByDeliveryID :one
SELECT id, delivery_id, origin_warehouse_id, current_warehouse_id, transfer_status, driver_id, transferred_at, received_at, transfer_note FROM delivery_transfers WHERE delivery_id = $1
`

func (q *Queries) GetDeliveryTransferByDeliveryID(ctx context.Context, deliveryID int32) (DeliveryTransfer, error) {
	row := q.db.QueryRow(ctx, getDeliveryTransferByDeliveryID, deliveryID)
	var i DeliveryTransfer
	err := row.Scan(
		&i.ID,
		&i.DeliveryID,
		&i.OriginWarehouseID,
		&i.CurrentWarehouseID,
		&i.TransferStatus,
		&i.DriverID,
		&i.TransferredAt,
		&i.ReceivedAt,
		&i.TransferNote,
	)
	return i, err
}

const getDeliveryTransferDetailsWithEmployeePrice = `-- name: GetDeliveryTransferDetailsWithEmployeePrice :many
SELECT
  d.barcode,
  d.price AS delivery_price,
  d.fdelivery_fee,
  d.total_price,
  d.customer_phone,
  so.phone AS store_owner_phone,
  so.first_name AS store_owner_first_name,
  so.last_name AS store_owner_last_name,
  dae.price AS employee_price
FROM delivery_actions_employee dae
JOIN deliveries d ON dae.delivery_id = d.id
JOIN store_owners so ON d.store_owner_id = so.id
WHERE dae.is_done = false
  AND dae.employee_id = $1
`

type GetDeliveryTransferDetailsWithEmployeePriceRow struct {
	Barcode             string
	DeliveryPrice       int32
	FdeliveryFee        int32
	TotalPrice          int32
	CustomerPhone       string
	StoreOwnerPhone     pgtype.Text
	StoreOwnerFirstName pgtype.Text
	StoreOwnerLastName  pgtype.Text
	EmployeePrice       int32
}

func (q *Queries) GetDeliveryTransferDetailsWithEmployeePrice(ctx context.Context, employeeID int32) ([]GetDeliveryTransferDetailsWithEmployeePriceRow, error) {
	rows, err := q.db.Query(ctx, getDeliveryTransferDetailsWithEmployeePrice, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeliveryTransferDetailsWithEmployeePriceRow
	for rows.Next() {
		var i GetDeliveryTransferDetailsWithEmployeePriceRow
		if err := rows.Scan(
			&i.Barcode,
			&i.DeliveryPrice,
			&i.FdeliveryFee,
			&i.TotalPrice,
			&i.CustomerPhone,
			&i.StoreOwnerPhone,
			&i.StoreOwnerFirstName,
			&i.StoreOwnerLastName,
			&i.EmployeePrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmplById = `-- name: GetEmplById :one
SELECT id, first_name, last_name, phone, email, password, location_address, setter_ku, setter_ar, setter_en, balance, warehouse_id, is_active, created_at, updated_at FROM empl WHERE id = $1
`

func (q *Queries) GetEmplById(ctx context.Context, id int32) (Empl, error) {
	row := q.db.QueryRow(ctx, getEmplById, id)
	var i Empl
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Email,
		&i.Password,
		&i.LocationAddress,
		&i.SetterKu,
		&i.SetterAr,
		&i.SetterEn,
		&i.Balance,
		&i.WarehouseID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFromCityByStoreId = `-- name: GetFromCityByStoreId :one
SELECT city_ku , city_en , city_ar FROM store_owners WHERE id = $1
`

type GetFromCityByStoreIdRow struct {
	CityKu pgtype.Text
	CityEn pgtype.Text
	CityAr pgtype.Text
}

func (q *Queries) GetFromCityByStoreId(ctx context.Context, id int32) (GetFromCityByStoreIdRow, error) {
	row := q.db.QueryRow(ctx, getFromCityByStoreId, id)
	var i GetFromCityByStoreIdRow
	err := row.Scan(&i.CityKu, &i.CityEn, &i.CityAr)
	return i, err
}

const getStoreBalanceById = `-- name: GetStoreBalanceById :one
SELECT in_store_balance
FROM store_balances
WHERE store_owner_id = $1
`

func (q *Queries) GetStoreBalanceById(ctx context.Context, storeOwnerID pgtype.Int4) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getStoreBalanceById, storeOwnerID)
	var in_store_balance pgtype.Int4
	err := row.Scan(&in_store_balance)
	return in_store_balance, err
}

const getStoreByID = `-- name: GetStoreByID :one
SELECT id, email, password, is_active FROM store_owners WHERE id = $1
`

type GetStoreByIDRow struct {
	ID       int32
	Email    pgtype.Text
	Password pgtype.Text
	IsActive pgtype.Bool
}

func (q *Queries) GetStoreByID(ctx context.Context, id int32) (GetStoreByIDRow, error) {
	row := q.db.QueryRow(ctx, getStoreByID, id)
	var i GetStoreByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.IsActive,
	)
	return i, err
}

const getStoreOwnerByEmail = `-- name: GetStoreOwnerByEmail :one
SELECT id, email, password, is_active
FROM store_owners
WHERE email = $1
LIMIT 1
`

type GetStoreOwnerByEmailRow struct {
	ID       int32
	Email    pgtype.Text
	Password pgtype.Text
	IsActive pgtype.Bool
}

func (q *Queries) GetStoreOwnerByEmail(ctx context.Context, email pgtype.Text) (GetStoreOwnerByEmailRow, error) {
	row := q.db.QueryRow(ctx, getStoreOwnerByEmail, email)
	var i GetStoreOwnerByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.IsActive,
	)
	return i, err
}

const getStoreProfileById = `-- name: GetStoreProfileById :one
SELECT id, first_name, last_name, phone, email, password, city_ku, city_en, city_ar, location_address, warehouse_id, is_active, created_at, updated_at FROM store_owners WHERE id = $1
`

func (q *Queries) GetStoreProfileById(ctx context.Context, id int32) (StoreOwner, error) {
	row := q.db.QueryRow(ctx, getStoreProfileById, id)
	var i StoreOwner
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Email,
		&i.Password,
		&i.CityKu,
		&i.CityEn,
		&i.CityAr,
		&i.LocationAddress,
		&i.WarehouseID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStoreSetter = `-- name: GetStoreSetter :one
SELECT ku ,en, ar FROM storesetter LIMIT 1
`

type GetStoreSetterRow struct {
	Ku string
	En string
	Ar string
}

func (q *Queries) GetStoreSetter(ctx context.Context) (GetStoreSetterRow, error) {
	row := q.db.QueryRow(ctx, getStoreSetter)
	var i GetStoreSetterRow
	err := row.Scan(&i.Ku, &i.En, &i.Ar)
	return i, err
}

const getWarehouseByEmail = `-- name: GetWarehouseByEmail :one
SELECT id, email, password, is_active FROM warehouses WHERE email = $1
`

type GetWarehouseByEmailRow struct {
	ID       int32
	Email    string
	Password string
	IsActive pgtype.Bool
}

func (q *Queries) GetWarehouseByEmail(ctx context.Context, email string) (GetWarehouseByEmailRow, error) {
	row := q.db.QueryRow(ctx, getWarehouseByEmail, email)
	var i GetWarehouseByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.IsActive,
	)
	return i, err
}

const getWarehouseByID = `-- name: GetWarehouseByID :one
SELECT id, email, password, is_active FROM warehouses WHERE id = $1
`

type GetWarehouseByIDRow struct {
	ID       int32
	Email    string
	Password string
	IsActive pgtype.Bool
}

func (q *Queries) GetWarehouseByID(ctx context.Context, id int32) (GetWarehouseByIDRow, error) {
	row := q.db.QueryRow(ctx, getWarehouseByID, id)
	var i GetWarehouseByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.IsActive,
	)
	return i, err
}

const getWarehouseIdByStoreId = `-- name: GetWarehouseIdByStoreId :one
SELECT warehouse_id FROM store_owners WHERE id = $1
`

func (q *Queries) GetWarehouseIdByStoreId(ctx context.Context, id int32) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getWarehouseIdByStoreId, id)
	var warehouse_id pgtype.Int4
	err := row.Scan(&warehouse_id)
	return warehouse_id, err
}

const insertDeliveryRouting = `-- name: InsertDeliveryRouting :exec
INSERT INTO delivery_routing (
  delivery_id,
  setter_ku,
  setter_ar,
  setter_en
) VALUES (
  $1, $2, $3 , $4
)
`

type InsertDeliveryRoutingParams struct {
	DeliveryID int32
	SetterKu   string
	SetterAr   string
	SetterEn   string
}

func (q *Queries) InsertDeliveryRouting(ctx context.Context, arg InsertDeliveryRoutingParams) error {
	_, err := q.db.Exec(ctx, insertDeliveryRouting,
		arg.DeliveryID,
		arg.SetterKu,
		arg.SetterAr,
		arg.SetterEn,
	)
	return err
}

const insertDeliveryStore = `-- name: InsertDeliveryStore :one
INSERT INTO deliveries (
  barcode,
  store_owner_id,
  customer_phone,
  note,

  from_city_ku,
  from_city_en,
  from_city_ar,

  to_city_ku,
  to_city_en,
  to_city_ar,

  to_subcity_ku,
  to_subcity_en,
  to_subcity_ar,

  to_specific_location,

  status,
  price,
  fdelivery_fee,
  total_price,
  warehouse_id
) VALUES (
  $1,  $2,  $3,  $4,
  $5,  $6,  $7,
  $8,  $9,  $10,
  $11, $12, $13,
  $14,
  $15, $16, $17, $18, $19
)
RETURNING id
`

type InsertDeliveryStoreParams struct {
	Barcode            string
	StoreOwnerID       int32
	CustomerPhone      string
	Note               pgtype.Text
	FromCityKu         string
	FromCityEn         string
	FromCityAr         string
	ToCityKu           string
	ToCityEn           string
	ToCityAr           string
	ToSubcityKu        string
	ToSubcityEn        string
	ToSubcityAr        string
	ToSpecificLocation pgtype.Text
	Status             string
	Price              int32
	FdeliveryFee       int32
	TotalPrice         int32
	WarehouseID        int32
}

func (q *Queries) InsertDeliveryStore(ctx context.Context, arg InsertDeliveryStoreParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertDeliveryStore,
		arg.Barcode,
		arg.StoreOwnerID,
		arg.CustomerPhone,
		arg.Note,
		arg.FromCityKu,
		arg.FromCityEn,
		arg.FromCityAr,
		arg.ToCityKu,
		arg.ToCityEn,
		arg.ToCityAr,
		arg.ToSubcityKu,
		arg.ToSubcityEn,
		arg.ToSubcityAr,
		arg.ToSpecificLocation,
		arg.Status,
		arg.Price,
		arg.FdeliveryFee,
		arg.TotalPrice,
		arg.WarehouseID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertDeliveryTransfer = `-- name: InsertDeliveryTransfer :exec
INSERT INTO delivery_transfers (
  delivery_id,
  origin_warehouse_id,
  current_warehouse_id,
  transfer_status,
  driver_id,
  transfer_note
) VALUES (
  $1, $2, $3, 'in_store', NULL, NULL
)
`

type InsertDeliveryTransferParams struct {
	DeliveryID         int32
	OriginWarehouseID  int32
	CurrentWarehouseID int32
}

func (q *Queries) InsertDeliveryTransfer(ctx context.Context, arg InsertDeliveryTransferParams) error {
	_, err := q.db.Exec(ctx, insertDeliveryTransfer, arg.DeliveryID, arg.OriginWarehouseID, arg.CurrentWarehouseID)
	return err
}

const insertWarehouseSetter = `-- name: InsertWarehouseSetter :one
INSERT INTO warehousesetter (ku, ar , en, warehouse_id)
VALUES ($1, $2, $3 , $4)
RETURNING id
`

type InsertWarehouseSetterParams struct {
	Ku          string
	Ar          string
	En          string
	WarehouseID int32
}

func (q *Queries) InsertWarehouseSetter(ctx context.Context, arg InsertWarehouseSetterParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertWarehouseSetter,
		arg.Ku,
		arg.Ar,
		arg.En,
		arg.WarehouseID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertWharehouses = `-- name: InsertWharehouses :one
INSERT INTO warehouses (fullname, locname, email, password, phone, is_active)
VALUES ($1,$2,$3,$4,$5,$6 ) RETURNING id
`

type InsertWharehousesParams struct {
	Fullname string
	Locname  string
	Email    string
	Password string
	Phone    string
	IsActive pgtype.Bool
}

func (q *Queries) InsertWharehouses(ctx context.Context, arg InsertWharehousesParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertWharehouses,
		arg.Fullname,
		arg.Locname,
		arg.Email,
		arg.Password,
		arg.Phone,
		arg.IsActive,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listDeliveriesByStoreFiltering = `-- name: ListDeliveriesByStoreFiltering :many
SELECT id, barcode, store_owner_id, customer_phone, note, from_city_ku, from_city_en, from_city_ar, to_city_ku, to_city_en, to_city_ar, to_subcity_ku, to_subcity_en, to_subcity_ar, to_specific_location, status, price, fdelivery_fee, total_price, warehouse_id, created_at FROM deliveries
WHERE store_owner_id = $1
  AND (COALESCE($2, '') = '' OR status = $2)
  AND (COALESCE($3, '') = '' OR barcode ILIKE '%' || $3 || '%')
  AND (COALESCE($4, '') = '' OR customer_phone ILIKE '%' || $4 || '%')
  AND (
    COALESCE($5, '') = '' OR
    to_city_en ILIKE '%' || $5 || '%' OR
    to_city_ar ILIKE '%' || $5 || '%' OR
    to_city_ku ILIKE '%' || $5 || '%'
  )
  AND (
    COALESCE($6, '') = '' OR
    to_subcity_en ILIKE '%' || $6 || '%' OR
    to_subcity_ar ILIKE '%' || $6 || '%' OR
    to_subcity_ku ILIKE '%' || $6 || '%'
  )
  AND (COALESCE($7, 0) = 0 OR price >= $7)
  AND (COALESCE($8, 0) = 0 OR price <= $8)
LIMIT $9 OFFSET $10
`

type ListDeliveriesByStoreFilteringParams struct {
	StoreOwnerID int32
	Column2      interface{}
	Column3      interface{}
	Column4      interface{}
	Column5      interface{}
	Column6      interface{}
	Column7      interface{}
	Column8      interface{}
	Limit        int32
	Offset       int32
}

func (q *Queries) ListDeliveriesByStoreFiltering(ctx context.Context, arg ListDeliveriesByStoreFilteringParams) ([]Delivery, error) {
	rows, err := q.db.Query(ctx, listDeliveriesByStoreFiltering,
		arg.StoreOwnerID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Delivery
	for rows.Next() {
		var i Delivery
		if err := rows.Scan(
			&i.ID,
			&i.Barcode,
			&i.StoreOwnerID,
			&i.CustomerPhone,
			&i.Note,
			&i.FromCityKu,
			&i.FromCityEn,
			&i.FromCityAr,
			&i.ToCityKu,
			&i.ToCityEn,
			&i.ToCityAr,
			&i.ToSubcityKu,
			&i.ToSubcityEn,
			&i.ToSubcityAr,
			&i.ToSpecificLocation,
			&i.Status,
			&i.Price,
			&i.FdeliveryFee,
			&i.TotalPrice,
			&i.WarehouseID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWarehouses = `-- name: ListWarehouses :many
SELECT 
    w.id AS warehouse_id,
    w.fullname,
    w.locname,
    w.email,
    w.phone,
    w.is_active,
    w.created_at,
    w.updated_at,
    ws.id AS setter_id,
    ws.ku,
    ws.en,
    ws.ar
FROM warehouses w
LEFT JOIN warehousesetter ws ON w.id = ws.warehouse_id
ORDER BY w.id ASC
`

type ListWarehousesRow struct {
	WarehouseID int32
	Fullname    string
	Locname     string
	Email       string
	Phone       string
	IsActive    pgtype.Bool
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	SetterID    pgtype.Int4
	Ku          pgtype.Text
	En          pgtype.Text
	Ar          pgtype.Text
}

func (q *Queries) ListWarehouses(ctx context.Context) ([]ListWarehousesRow, error) {
	rows, err := q.db.Query(ctx, listWarehouses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWarehousesRow
	for rows.Next() {
		var i ListWarehousesRow
		if err := rows.Scan(
			&i.WarehouseID,
			&i.Fullname,
			&i.Locname,
			&i.Email,
			&i.Phone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SetterID,
			&i.Ku,
			&i.En,
			&i.Ar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginEmplWithEmailAndPassword = `-- name: LoginEmplWithEmailAndPassword :one
SELECT id, first_name, last_name, phone, email, password, location_address, setter_ku, setter_ar, setter_en, balance, warehouse_id, is_active, created_at, updated_at FROM empl
WHERE email = $1 AND password = $2
LIMIT 1
`

type LoginEmplWithEmailAndPasswordParams struct {
	Email    pgtype.Text
	Password pgtype.Text
}

func (q *Queries) LoginEmplWithEmailAndPassword(ctx context.Context, arg LoginEmplWithEmailAndPasswordParams) (Empl, error) {
	row := q.db.QueryRow(ctx, loginEmplWithEmailAndPassword, arg.Email, arg.Password)
	var i Empl
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Email,
		&i.Password,
		&i.LocationAddress,
		&i.SetterKu,
		&i.SetterAr,
		&i.SetterEn,
		&i.Balance,
		&i.WarehouseID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDeliveryStatusToPending = `-- name: UpdateDeliveryStatusToPending :exec
UPDATE deliveries
SET status = 'pending'
WHERE id = $1
`

func (q *Queries) UpdateDeliveryStatusToPending(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateDeliveryStatusToPending, id)
	return err
}

const updateDriverForDelivery = `-- name: UpdateDriverForDelivery :exec
UPDATE delivery_transfers
SET driver_id = $1
WHERE delivery_id = $2
`

type UpdateDriverForDeliveryParams struct {
	DriverID   pgtype.Int4
	DeliveryID int32
}

func (q *Queries) UpdateDriverForDelivery(ctx context.Context, arg UpdateDriverForDeliveryParams) error {
	_, err := q.db.Exec(ctx, updateDriverForDelivery, arg.DriverID, arg.DeliveryID)
	return err
}

const updateStoreBalanceOnTransfer = `-- name: UpdateStoreBalanceOnTransfer :exec
UPDATE store_balances
SET
    in_store_balance = in_store_balance - $1,
    pending_balance = pending_balance + $1,
    updated_at = now()
WHERE store_owner_id = $2
`

type UpdateStoreBalanceOnTransferParams struct {
	InStoreBalance pgtype.Int4
	StoreOwnerID   pgtype.Int4
}

func (q *Queries) UpdateStoreBalanceOnTransfer(ctx context.Context, arg UpdateStoreBalanceOnTransferParams) error {
	_, err := q.db.Exec(ctx, updateStoreBalanceOnTransfer, arg.InStoreBalance, arg.StoreOwnerID)
	return err
}

const updateWarehouseInfo = `-- name: UpdateWarehouseInfo :exec
UPDATE warehouses
SET
  fullname = $1,
  locname = $2,
  email = $3,
  phone = $4,
  is_active = $5,
  updated_at = NOW()
WHERE id = $6
`

type UpdateWarehouseInfoParams struct {
	Fullname string
	Locname  string
	Email    string
	Phone    string
	IsActive pgtype.Bool
	ID       int32
}

func (q *Queries) UpdateWarehouseInfo(ctx context.Context, arg UpdateWarehouseInfoParams) error {
	_, err := q.db.Exec(ctx, updateWarehouseInfo,
		arg.Fullname,
		arg.Locname,
		arg.Email,
		arg.Phone,
		arg.IsActive,
		arg.ID,
	)
	return err
}

const updateWarehouseSetter = `-- name: UpdateWarehouseSetter :exec
UPDATE warehousesetter
SET
  ku = $1,
  en = $2,

  ar = $3
WHERE warehouse_id = $4
`

type UpdateWarehouseSetterParams struct {
	Ku          string
	En          string
	Ar          string
	WarehouseID int32
}

func (q *Queries) UpdateWarehouseSetter(ctx context.Context, arg UpdateWarehouseSetterParams) error {
	_, err := q.db.Exec(ctx, updateWarehouseSetter,
		arg.Ku,
		arg.En,
		arg.Ar,
		arg.WarehouseID,
	)
	return err
}
