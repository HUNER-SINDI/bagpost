// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addToInStoreBalance = `-- name: AddToInStoreBalance :exec
UPDATE store_balances
SET in_store_balance = in_store_balance + $1,
    updated_at = now()
WHERE store_owner_id = $2
`

type AddToInStoreBalanceParams struct {
	InStoreBalance pgtype.Int4
	StoreOwnerID   pgtype.Int4
}

func (q *Queries) AddToInStoreBalance(ctx context.Context, arg AddToInStoreBalanceParams) error {
	_, err := q.db.Exec(ctx, addToInStoreBalance, arg.InStoreBalance, arg.StoreOwnerID)
	return err
}

const countDeliveriesById = `-- name: CountDeliveriesById :one
SELECT COUNT(*) FROM deliveries WHERE store_owner_id = $1
`

func (q *Queries) CountDeliveriesById(ctx context.Context, storeOwnerID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countDeliveriesById, storeOwnerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deactivateStoreAccountById = `-- name: DeactivateStoreAccountById :exec
UPDATE store_owners
SET is_active = false
WHERE id = $1
`

func (q *Queries) DeactivateStoreAccountById(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deactivateStoreAccountById, id)
	return err
}

const deleteWarehouse = `-- name: DeleteWarehouse :exec
DELETE FROM warehouses
WHERE id = $1
`

func (q *Queries) DeleteWarehouse(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteWarehouse, id)
	return err
}

const getAdminByEmailAndPassword = `-- name: GetAdminByEmailAndPassword :one
SELECT id, email, password, created_at, updated_at FROM admins
WHERE email = $1 AND password = $2
LIMIT 1
`

type GetAdminByEmailAndPasswordParams struct {
	Email    string
	Password string
}

func (q *Queries) GetAdminByEmailAndPassword(ctx context.Context, arg GetAdminByEmailAndPasswordParams) (Admin, error) {
	row := q.db.QueryRow(ctx, getAdminByEmailAndPassword, arg.Email, arg.Password)
	var i Admin
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllAds = `-- name: GetAllAds :many
SELECT id, url FROM ads
`

func (q *Queries) GetAllAds(ctx context.Context) ([]Ad, error) {
	rows, err := q.db.Query(ctx, getAllAds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ad
	for rows.Next() {
		var i Ad
		if err := rows.Scan(&i.ID, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRoutesByWarehouseId = `-- name: GetAllRoutesByWarehouseId :many
SELECT 
  cr.id,
  cr.city_name_en,
  cr.city_name_ar,
  cr.city_name_ku,
  COALESCE(
    (
      SELECT json_agg(
        json_build_object(
          'id', sc.id,
          'subcity_name_en', sc.subcity_name_en,
          'subcity_name_ar', sc.subcity_name_ar,
          'subcity_name_ku', sc.subcity_name_ku,
          'price', sc.price
        )
      )
      FROM subcities sc
      WHERE sc.city_route_id = cr.id
    ), '[]'
  ) AS subcities
FROM city_routes cr WHERE cr.warehouse_id = $1
ORDER BY cr.id
`

type GetAllRoutesByWarehouseIdRow struct {
	ID         int32
	CityNameEn pgtype.Text
	CityNameAr pgtype.Text
	CityNameKu pgtype.Text
	Subcities  interface{}
}

func (q *Queries) GetAllRoutesByWarehouseId(ctx context.Context, warehouseID pgtype.Int4) ([]GetAllRoutesByWarehouseIdRow, error) {
	rows, err := q.db.Query(ctx, getAllRoutesByWarehouseId, warehouseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRoutesByWarehouseIdRow
	for rows.Next() {
		var i GetAllRoutesByWarehouseIdRow
		if err := rows.Scan(
			&i.ID,
			&i.CityNameEn,
			&i.CityNameAr,
			&i.CityNameKu,
			&i.Subcities,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStoreBalanceById = `-- name: GetAllStoreBalanceById :one
SELECT id, store_owner_id, in_store_balance, pending_balance, paid_balance, refused_balance, updated_at FROM store_balances WHERE id = $1
`

func (q *Queries) GetAllStoreBalanceById(ctx context.Context, id int32) (StoreBalance, error) {
	row := q.db.QueryRow(ctx, getAllStoreBalanceById, id)
	var i StoreBalance
	err := row.Scan(
		&i.ID,
		&i.StoreOwnerID,
		&i.InStoreBalance,
		&i.PendingBalance,
		&i.PaidBalance,
		&i.RefusedBalance,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliveryRoutes = `-- name: GetDeliveryRoutes :many
SELECT id, delivery_id, setter_ku, setter_en, setter_ar, created_at FROM delivery_routing WHERE delivery_id = $1 ORDER BY created_at ASC
`

func (q *Queries) GetDeliveryRoutes(ctx context.Context, deliveryID int32) ([]DeliveryRouting, error) {
	rows, err := q.db.Query(ctx, getDeliveryRoutes, deliveryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryRouting
	for rows.Next() {
		var i DeliveryRouting
		if err := rows.Scan(
			&i.ID,
			&i.DeliveryID,
			&i.SetterKu,
			&i.SetterEn,
			&i.SetterAr,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeliveryStatusByStoreId = `-- name: GetDeliveryStatusByStoreId :many
SELECT status, COUNT(*) as count
FROM deliveries
WHERE store_owner_id = $1
GROUP BY status
`

type GetDeliveryStatusByStoreIdRow struct {
	Status string
	Count  int64
}

func (q *Queries) GetDeliveryStatusByStoreId(ctx context.Context, storeOwnerID int32) ([]GetDeliveryStatusByStoreIdRow, error) {
	rows, err := q.db.Query(ctx, getDeliveryStatusByStoreId, storeOwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeliveryStatusByStoreIdRow
	for rows.Next() {
		var i GetDeliveryStatusByStoreIdRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFromCityByStoreId = `-- name: GetFromCityByStoreId :one
SELECT city_ku , city_en , city_ar FROM store_owners WHERE id = $1
`

type GetFromCityByStoreIdRow struct {
	CityKu pgtype.Text
	CityEn pgtype.Text
	CityAr pgtype.Text
}

func (q *Queries) GetFromCityByStoreId(ctx context.Context, id int32) (GetFromCityByStoreIdRow, error) {
	row := q.db.QueryRow(ctx, getFromCityByStoreId, id)
	var i GetFromCityByStoreIdRow
	err := row.Scan(&i.CityKu, &i.CityEn, &i.CityAr)
	return i, err
}

const getStoreBalanceById = `-- name: GetStoreBalanceById :one
SELECT in_store_balance
FROM store_balances
WHERE store_owner_id = $1
`

func (q *Queries) GetStoreBalanceById(ctx context.Context, storeOwnerID pgtype.Int4) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getStoreBalanceById, storeOwnerID)
	var in_store_balance pgtype.Int4
	err := row.Scan(&in_store_balance)
	return in_store_balance, err
}

const getStoreByID = `-- name: GetStoreByID :one
SELECT id, email, password, is_active FROM store_owners WHERE id = $1
`

type GetStoreByIDRow struct {
	ID       int32
	Email    pgtype.Text
	Password pgtype.Text
	IsActive pgtype.Bool
}

func (q *Queries) GetStoreByID(ctx context.Context, id int32) (GetStoreByIDRow, error) {
	row := q.db.QueryRow(ctx, getStoreByID, id)
	var i GetStoreByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.IsActive,
	)
	return i, err
}

const getStoreOwnerByEmail = `-- name: GetStoreOwnerByEmail :one
SELECT id, email, password, is_active
FROM store_owners
WHERE email = $1
LIMIT 1
`

type GetStoreOwnerByEmailRow struct {
	ID       int32
	Email    pgtype.Text
	Password pgtype.Text
	IsActive pgtype.Bool
}

func (q *Queries) GetStoreOwnerByEmail(ctx context.Context, email pgtype.Text) (GetStoreOwnerByEmailRow, error) {
	row := q.db.QueryRow(ctx, getStoreOwnerByEmail, email)
	var i GetStoreOwnerByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.IsActive,
	)
	return i, err
}

const getStoreProfileById = `-- name: GetStoreProfileById :one
SELECT id, first_name, last_name, phone, email, password, city_ku, city_en, city_ar, location_address, warehouse_id, is_active, created_at, updated_at FROM store_owners WHERE id = $1
`

func (q *Queries) GetStoreProfileById(ctx context.Context, id int32) (StoreOwner, error) {
	row := q.db.QueryRow(ctx, getStoreProfileById, id)
	var i StoreOwner
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Email,
		&i.Password,
		&i.CityKu,
		&i.CityEn,
		&i.CityAr,
		&i.LocationAddress,
		&i.WarehouseID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStoreSetter = `-- name: GetStoreSetter :one
SELECT ku ,en, ar FROM storesetter LIMIT 1
`

type GetStoreSetterRow struct {
	Ku string
	En string
	Ar string
}

func (q *Queries) GetStoreSetter(ctx context.Context) (GetStoreSetterRow, error) {
	row := q.db.QueryRow(ctx, getStoreSetter)
	var i GetStoreSetterRow
	err := row.Scan(&i.Ku, &i.En, &i.Ar)
	return i, err
}

const getWarehouseByEmail = `-- name: GetWarehouseByEmail :one
SELECT id, email, password, is_active FROM warehouses WHERE email = $1
`

type GetWarehouseByEmailRow struct {
	ID       int32
	Email    string
	Password string
	IsActive pgtype.Bool
}

func (q *Queries) GetWarehouseByEmail(ctx context.Context, email string) (GetWarehouseByEmailRow, error) {
	row := q.db.QueryRow(ctx, getWarehouseByEmail, email)
	var i GetWarehouseByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.IsActive,
	)
	return i, err
}

const getWarehouseByID = `-- name: GetWarehouseByID :one
SELECT id, email, password, is_active FROM warehouses WHERE id = $1
`

type GetWarehouseByIDRow struct {
	ID       int32
	Email    string
	Password string
	IsActive pgtype.Bool
}

func (q *Queries) GetWarehouseByID(ctx context.Context, id int32) (GetWarehouseByIDRow, error) {
	row := q.db.QueryRow(ctx, getWarehouseByID, id)
	var i GetWarehouseByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.IsActive,
	)
	return i, err
}

const getWarehouseIdByStoreId = `-- name: GetWarehouseIdByStoreId :one
SELECT warehouse_id FROM store_owners WHERE id = $1
`

func (q *Queries) GetWarehouseIdByStoreId(ctx context.Context, id int32) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getWarehouseIdByStoreId, id)
	var warehouse_id pgtype.Int4
	err := row.Scan(&warehouse_id)
	return warehouse_id, err
}

const insertDeliveryRouting = `-- name: InsertDeliveryRouting :exec
INSERT INTO delivery_routing (
  delivery_id,
  setter_ku,
  setter_ar,
  setter_en
) VALUES (
  $1, $2, $3 , $4
)
`

type InsertDeliveryRoutingParams struct {
	DeliveryID int32
	SetterKu   string
	SetterAr   string
	SetterEn   string
}

func (q *Queries) InsertDeliveryRouting(ctx context.Context, arg InsertDeliveryRoutingParams) error {
	_, err := q.db.Exec(ctx, insertDeliveryRouting,
		arg.DeliveryID,
		arg.SetterKu,
		arg.SetterAr,
		arg.SetterEn,
	)
	return err
}

const insertDeliveryStore = `-- name: InsertDeliveryStore :one
INSERT INTO deliveries (
  barcode,
  store_owner_id,
  customer_phone,
  note,

  from_city_ku,
  from_city_en,
  from_city_ar,

  to_city_ku,
  to_city_en,
  to_city_ar,

  to_subcity_ku,
  to_subcity_en,
  to_subcity_ar,

  to_specific_location,

  status,
  price,
  fdelivery_fee,
  total_price,
  warehouse_id
) VALUES (
  $1,  $2,  $3,  $4,
  $5,  $6,  $7,
  $8,  $9,  $10,
  $11, $12, $13,
  $14,
  $15, $16, $17, $18, $19
)
RETURNING id
`

type InsertDeliveryStoreParams struct {
	Barcode            string
	StoreOwnerID       int32
	CustomerPhone      string
	Note               pgtype.Text
	FromCityKu         string
	FromCityEn         string
	FromCityAr         string
	ToCityKu           string
	ToCityEn           string
	ToCityAr           string
	ToSubcityKu        string
	ToSubcityEn        string
	ToSubcityAr        string
	ToSpecificLocation pgtype.Text
	Status             string
	Price              int32
	FdeliveryFee       int32
	TotalPrice         int32
	WarehouseID        int32
}

func (q *Queries) InsertDeliveryStore(ctx context.Context, arg InsertDeliveryStoreParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertDeliveryStore,
		arg.Barcode,
		arg.StoreOwnerID,
		arg.CustomerPhone,
		arg.Note,
		arg.FromCityKu,
		arg.FromCityEn,
		arg.FromCityAr,
		arg.ToCityKu,
		arg.ToCityEn,
		arg.ToCityAr,
		arg.ToSubcityKu,
		arg.ToSubcityEn,
		arg.ToSubcityAr,
		arg.ToSpecificLocation,
		arg.Status,
		arg.Price,
		arg.FdeliveryFee,
		arg.TotalPrice,
		arg.WarehouseID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertDeliveryTransfer = `-- name: InsertDeliveryTransfer :exec
INSERT INTO delivery_transfers (
  delivery_id,
  origin_warehouse_id,
  current_warehouse_id,
  transfer_status,
  driver_id,
  transfer_note
) VALUES (
  $1, $2, $3, 'in_store', NULL, NULL
)
`

type InsertDeliveryTransferParams struct {
	DeliveryID         int32
	OriginWarehouseID  int32
	CurrentWarehouseID int32
}

func (q *Queries) InsertDeliveryTransfer(ctx context.Context, arg InsertDeliveryTransferParams) error {
	_, err := q.db.Exec(ctx, insertDeliveryTransfer, arg.DeliveryID, arg.OriginWarehouseID, arg.CurrentWarehouseID)
	return err
}

const insertWarehouseSetter = `-- name: InsertWarehouseSetter :one
INSERT INTO warehousesetter (ku, ar , en, warehouse_id)
VALUES ($1, $2, $3 , $4)
RETURNING id
`

type InsertWarehouseSetterParams struct {
	Ku          string
	Ar          string
	En          string
	WarehouseID int32
}

func (q *Queries) InsertWarehouseSetter(ctx context.Context, arg InsertWarehouseSetterParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertWarehouseSetter,
		arg.Ku,
		arg.Ar,
		arg.En,
		arg.WarehouseID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertWharehouses = `-- name: InsertWharehouses :one
INSERT INTO warehouses (fullname, locname, email, password, phone, is_active)
VALUES ($1,$2,$3,$4,$5,$6 ) RETURNING id
`

type InsertWharehousesParams struct {
	Fullname string
	Locname  string
	Email    string
	Password string
	Phone    string
	IsActive pgtype.Bool
}

func (q *Queries) InsertWharehouses(ctx context.Context, arg InsertWharehousesParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertWharehouses,
		arg.Fullname,
		arg.Locname,
		arg.Email,
		arg.Password,
		arg.Phone,
		arg.IsActive,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listDeliveriesByStoreFiltering = `-- name: ListDeliveriesByStoreFiltering :many
SELECT id, barcode, store_owner_id, customer_phone, note, from_city_ku, from_city_en, from_city_ar, to_city_ku, to_city_en, to_city_ar, to_subcity_ku, to_subcity_en, to_subcity_ar, to_specific_location, status, price, fdelivery_fee, total_price, warehouse_id, created_at FROM deliveries
WHERE store_owner_id = $1
  AND (COALESCE($2, '') = '' OR status = $2)
  AND (COALESCE($3, '') = '' OR barcode ILIKE '%' || $3 || '%')
  AND (COALESCE($4, '') = '' OR customer_phone ILIKE '%' || $4 || '%')
  AND (
    COALESCE($5, '') = '' OR
    to_city_en ILIKE '%' || $5 || '%' OR
    to_city_ar ILIKE '%' || $5 || '%' OR
    to_city_ku ILIKE '%' || $5 || '%'
  )
  AND (
    COALESCE($6, '') = '' OR
    to_subcity_en ILIKE '%' || $6 || '%' OR
    to_subcity_ar ILIKE '%' || $6 || '%' OR
    to_subcity_ku ILIKE '%' || $6 || '%'
  )
  AND (COALESCE($7, 0) = 0 OR price >= $7)
  AND (COALESCE($8, 0) = 0 OR price <= $8)
LIMIT $9 OFFSET $10
`

type ListDeliveriesByStoreFilteringParams struct {
	StoreOwnerID int32
	Column2      interface{}
	Column3      interface{}
	Column4      interface{}
	Column5      interface{}
	Column6      interface{}
	Column7      interface{}
	Column8      interface{}
	Limit        int32
	Offset       int32
}

func (q *Queries) ListDeliveriesByStoreFiltering(ctx context.Context, arg ListDeliveriesByStoreFilteringParams) ([]Delivery, error) {
	rows, err := q.db.Query(ctx, listDeliveriesByStoreFiltering,
		arg.StoreOwnerID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Delivery
	for rows.Next() {
		var i Delivery
		if err := rows.Scan(
			&i.ID,
			&i.Barcode,
			&i.StoreOwnerID,
			&i.CustomerPhone,
			&i.Note,
			&i.FromCityKu,
			&i.FromCityEn,
			&i.FromCityAr,
			&i.ToCityKu,
			&i.ToCityEn,
			&i.ToCityAr,
			&i.ToSubcityKu,
			&i.ToSubcityEn,
			&i.ToSubcityAr,
			&i.ToSpecificLocation,
			&i.Status,
			&i.Price,
			&i.FdeliveryFee,
			&i.TotalPrice,
			&i.WarehouseID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWarehouses = `-- name: ListWarehouses :many
SELECT 
    w.id AS warehouse_id,
    w.fullname,
    w.locname,
    w.email,
    w.phone,
    w.is_active,
    w.created_at,
    w.updated_at,
    ws.id AS setter_id,
    ws.ku,
    ws.en,
    ws.ar
FROM warehouses w
LEFT JOIN warehousesetter ws ON w.id = ws.warehouse_id
ORDER BY w.id ASC
`

type ListWarehousesRow struct {
	WarehouseID int32
	Fullname    string
	Locname     string
	Email       string
	Phone       string
	IsActive    pgtype.Bool
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	SetterID    pgtype.Int4
	Ku          pgtype.Text
	En          pgtype.Text
	Ar          pgtype.Text
}

func (q *Queries) ListWarehouses(ctx context.Context) ([]ListWarehousesRow, error) {
	rows, err := q.db.Query(ctx, listWarehouses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWarehousesRow
	for rows.Next() {
		var i ListWarehousesRow
		if err := rows.Scan(
			&i.WarehouseID,
			&i.Fullname,
			&i.Locname,
			&i.Email,
			&i.Phone,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SetterID,
			&i.Ku,
			&i.En,
			&i.Ar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWarehouseInfo = `-- name: UpdateWarehouseInfo :exec
UPDATE warehouses
SET
  fullname = $1,
  locname = $2,
  email = $3,
  phone = $4,
  is_active = $5,
  updated_at = NOW()
WHERE id = $6
`

type UpdateWarehouseInfoParams struct {
	Fullname string
	Locname  string
	Email    string
	Phone    string
	IsActive pgtype.Bool
	ID       int32
}

func (q *Queries) UpdateWarehouseInfo(ctx context.Context, arg UpdateWarehouseInfoParams) error {
	_, err := q.db.Exec(ctx, updateWarehouseInfo,
		arg.Fullname,
		arg.Locname,
		arg.Email,
		arg.Phone,
		arg.IsActive,
		arg.ID,
	)
	return err
}

const updateWarehouseSetter = `-- name: UpdateWarehouseSetter :exec
UPDATE warehousesetter
SET
  ku = $1,
  en = $2,

  ar = $3
WHERE warehouse_id = $4
`

type UpdateWarehouseSetterParams struct {
	Ku          string
	En          string
	Ar          string
	WarehouseID int32
}

func (q *Queries) UpdateWarehouseSetter(ctx context.Context, arg UpdateWarehouseSetterParams) error {
	_, err := q.db.Exec(ctx, updateWarehouseSetter,
		arg.Ku,
		arg.En,
		arg.Ar,
		arg.WarehouseID,
	)
	return err
}
